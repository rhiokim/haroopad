{
  "name": "buildmail",
  "version": "1.2.0",
  "description": "buildmail is a low level rfc2822 message composer. Define your own mime tree, no magic included.",
  "author": {
    "name": "Andris Reinman",
    "email": "andris@kreata.ee"
  },
  "keywords": [
    "RFC2822",
    "mime"
  ],
  "license": "MIT",
  "scripts": {
    "test": "grunt"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/buildmail.git"
  },
  "main": "src/buildmail",
  "dependencies": {
    "addressparser": "^0.3.1",
    "hyperquest": "^0.3.0",
    "libbase64": "^0.1.0",
    "libmime": "^0.1.3",
    "libqp": "^0.1.1"
  },
  "devDependencies": {
    "chai": "~1.8.1",
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.8.0",
    "grunt-mocha-test": "~0.10.0",
    "sinon": "^1.9.0"
  },
  "readme": "# buildmail\n\nLow level rfc2822 message composer that streams output. Define your own mime tree, no magic included.\n\nPorted from [MailBuild](https://github.com/whiteout-io/mailbuild) of the [emailjs.org](http://emailjs.org/) project. This port uses similar API but is for Node only and streams the output.\n\n## Usage\n\nInstall with npm\n\n    npm install buildmail\n\nRequire in your scripts\n\n```javascript\nvar BuildMail = require('buildmail');\n```\n\n## API\n\nCreate a new `BuildMail` object with\n\n```javascript\nvar builder = new BuildMail(contentType [, options]);\n```\n\nWhere\n\n  * **contentType** - define the content type for created node. Can be left blank for attachments (content type derived from `filename` option if available)\n  * **options** - an optional options object\n    * **filename** - *String* filename for an attachment node\n    * **baseBoundary** - *String* shared part of the unique multipart boundary (generated randomly if not set)\n    * **keepBcc** - *Boolean* If true keep the Bcc value in generated headers (default is to remove it)\n\n## Methods\n\nThe same methods apply to the root node created with `new BuildMail()` and to any child nodes.\n\n### createChild\n\nCreates and appends a child node to the node object\n\n```javascript\nnode.createChild(contentType, options)\n```\n\nThe same arguments apply as with `new BuildMail()`. Created node object is returned.\n\n**Example**\n\n```javascript\nnew BuildMail('multipart/mixed').\n    createChild('multipart/related').\n        createChild('text/plain');\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n  ↳ multipart/related\n      ↳ text/plain\n```\n\n### appendChild\n\nAppends an existing child node to the node object. Removes the node from an existing tree if needed.\n\n```javascript\nnode.appendChild(childNode)\n```\n\nWhere\n\n  * **childNode** - child node to be appended\n\nMethod returns appended child node.\n\n**Example**\n\n```javascript\nvar childNode = new BuildMail('text/plain'),\n    rootNode = new BuildMail('multipart/mixed');\nrootnode.appendChild(childNode);\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n  ↳ text/plain\n```\n\n## replace\n\nReplaces current node with another node\n\n```javascript\nnode.replace(replacementNode)\n```\n\nWhere\n\n  * **replacementNode** - node to replace the current node with\n\nMethod returns replacement node.\n\n**Example**\n\n```javascript\nvar rootNode = new BuildMail('multipart/mixed'),\n    childNode = rootNode.createChild('text/plain');\nchildNode.replace(new BuildMail('text/html'));\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n  ↳ text/html\n```\n\n## remove\n\nRemoves current node from the mime tree. Does not make a lot of sense for a root node.\n\n```javascript\nnode.remove();\n```\n\nMethod returns removed node.\n\n**Example**\n\n```javascript\n\nvar rootNode = new BuildMail('multipart/mixed'),\n    childNode = rootNode.createChild('text/plain');\nchildNode.remove();\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n```\n\n## setHeader\n\nSets a header value. If the value for selected key exists, it is overwritten.\n\nYou can set multiple values as well by using `[{key:'', value:''}]` or\n`{key: 'value'}` structures as the first argument.\n\n```javascript\nnode.setHeader(key, value);\n```\n\nWhere\n\n  * **key** - *String|Array|Object* Header key or a list of key value pairs\n  * **value** - *String* Header value\n\nMethod returns current node.\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').\n    setHeader('content-disposition', 'inline').\n    setHeader({\n        'content-transfer-encoding': '7bit'\n    }).\n    setHeader([\n        {key: 'message-id', value: 'abcde'}\n```\n\nGenerates the following header:\n\n```\nContent-type: text/plain\nContent-Disposition: inline\nContent-Transfer-Encoding: 7bit\nMessage-Id: <abcde>\n```\n\n## addHeader\n\nAdds a header value. If the value for selected key exists, the value is appended\nas a new field and old one is not touched.\n\nYou can set multiple values as well by using `[{key:'', value:''}]` or\n`{key: 'value'}` structures as the first argument.\n\n```javascript\nnode.addHeader(key, value);\n```\n\nWhere\n\n  * **key** - *String|Array|Object* Header key or a list of key value pairs\n  * **value** - *String* Header value\n\nMethod returns current node.\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').\n    addHeader('X-Spam', '1').\n    setHeader({\n        'x-spam': '2'\n    }).\n    setHeader([\n        {key: 'x-spam', value: '3'}\n    ]);\n```\n\nGenerates the following header:\n\n```\nContent-type: text/plain\nX-Spam: 1\nX-Spam: 2\nX-Spam: 3\n```\n\n## getHeader\n\nRetrieves the first mathcing value of a selected key\n\n```javascript\nnode.getHeader(key)\n```\n\nWhere\n\n  * **key** - *String* Key to search for\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').getHeader('content-type'); // text/plain\n```\n\n## buildHeaders\n\nBuilds the current header info into a header block that can be used in an e-mail\n\n```javascript\nvar headers = node.buildHeaders()\n```\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').\n    addHeader('X-Spam', '1').\n    setHeader({\n        'x-spam': '2'\n    }).\n    setHeader([\n        {key: 'x-spam', value: '3'}\n    ]).buildHeaders();\n```\n\nreturns the following String\n\n```\nContent-Type: text/plain\nX-Spam: 3\nDate: Sat, 21 Jun 2014 10:52:44 +0000\nMessage-Id: <1403347964894-790a5296-0eb7c7c7-6440334f@localhost>\nMIME-Version: 1.0\n```\n\nIf the node is the root node, then `Date` and `Message-Id` values are generated automatically if missing\n\n## setContent\n\nSets body content for current node. If the value is a string and Content-Type is text/* then charset is set automatically.\nIf the value is a Buffer or a Stream you need to specify the charset yourself.\n\n```javascript\nnode.setContent(body)\n```\n\nWhere\n\n  * **body** - *String|Buffer|Stream|Object* body content\n\nIf the value is an object, it should include one of the following properties\n\n  * **path** - path to a file that will be used as the content\n  * **href** - URL that will be used as the content\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').setContent('Hello world!');\n\nnew BuildMail('text/plain; charset=utf-8').setContent(fs.createReadStream('message.txt'));\n```\n\n## build\n\nBuilds the rfc2822 message from the current node. If this is a root node, mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n\n```javascript\nnode.build(callback)\n```\n\nCallback returns the rfc2822 message as a Buffer\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').setContent('Hello world!').build(function(err, mail){\n    console.log(mail.toString('ascii'));\n});\n```\n\nReturns the following string:\n\n```\nContent-type: text/plain\nDate: <current datetime>\nMessage-Id: <generated value>\nMIME-Version: 1.0\n\nHello world!\n```\n\n## createReadStream\n\nIf you manage large attachments you probably do not want to generate but stream the message.\n\n```javascript\nvar stream = node.createReadStream(options)\n```\n\nWhere\n\n  * **options** - *Object* optional Stream options (ie. `highWaterMark`)\n\n**Example**\n\n```javascript\nvar message = new BuildMail();\nmessage.addHeader({\n    from: 'From <from@example.com>',\n    to: 'receiver1@example.com',\n    cc: 'receiver2@example.com'\n});\nmessage.setContent(fs.createReadStream('message.txt'));\nmessage.createReadStream().pipe(fs.createWriteStream('message.eml'));\n```\n\n## transform\n\nIf you want to modify the created stream, you can add transform streams that the output will be piped through.\n\n```javascript\nnode.transform(transformStream)\n```\n\nWhere\n\n  * **transformStream** - *Stream* or *Function* Transform stream that the output will go through before returing with `createReadStream`. If the value is a function the function should return a transform stream object when called.\n\n**Example**\n\n```javascript\nvar PassThrough = require('stream').PassThrough;\nvar message = new BuildMail();\nmessage.addHeader({\n    from: 'From <from@example.com>',\n    to: 'receiver1@example.com',\n    cc: 'receiver2@example.com'\n});\nmessage.setContent(fs.createReadStream('message.txt'));\nmessage.transform(new PassThrough()); // add a stream that the output will be piped through\nmessage.createReadStream().pipe(fs.createWriteStream('message.eml'));\n```\n\n## setEnvelope\n\nSet envelope object to use. If one is not set, it is generated based ong the headers.\n\n```javascript\nnode.setEnvelope(envelope)\n```\n\nWhere\n\n  * **envelope** is an envelope object in the form of `{from:'address', to: ['addresses']}`\n\n## getEnvelope\n\nGenerates a SMTP envelope object. Makes sense only for root node.\n\n```javascript\nvar envelope = node.generateEnvelope()\n```\n\nMethod returns the envelope in the form of `{from:'address', to: ['addresses']}`\n\n**Example**\n\n```javascript\nnew BuildMail().\n    addHeader({\n        from: 'From <from@example.com>',\n        to: 'receiver1@example.com',\n        cc: 'receiver2@example.com'\n    }).\n    getEnvelope();\n```\n\nReturns the following object:\n\n```json\n{\n    'from': 'from@example.com',\n    'to': ['receiver1@example.com', 'receiver2@example.com']\n}\n```\n\n## getAddresses\n\nReturns an address container object. Includes all parsed addresses from From, Sender, To, Cc, Bcc and Reply-To fields.\n\nWhile `getEnvelope()` returns 'from' value as a single address (the first one encountered) then `getAddresses` return all values as arrays, including `from`. Additionally while `getEnvelope` returns only `from` and a combined `to` value then `getAddresses` returns all fields separately.\n\nPossbile return values (all arrays in the form of `[{name:'', address:''}]`):\n\n  * **from**\n  * **sender**\n  * **'reply-to'**\n  * **to**\n  * **cc**\n  * **bcc**\n\nIf no addresses were found for a particular field, the field is not set in the response object.\n\n**Example**\n\n```javascript\nnew BuildMail().\n    addHeader({\n        from: 'From <from@example.com>',\n        to: '\"Receiver\" receiver1@example.com',\n        cc: 'receiver2@example.com'\n    }).\n    getAddresses();\n```\n\nReturns the following object:\n\n```javascript\n{\n    from: [{\n        name: 'From',\n        address: 'from@example.com'\n    }],\n    to: [{\n        name: 'Receiver',\n        address: 'receiver1@example.com'\n    }],\n    cc: [{\n        name: '',\n        address: 'receiver2@example.com'\n    }]\n}\n```\n\n## Notes\n\n### Addresses\n\nWhen setting address headers (`From`, `To`, `Cc`, `Bcc`) use of unicode is allowed. If needed\nthe addresses are converted to punycode automatically.\n\n### Attachments\n\nFor attachments you should minimally set `filename` option and `Content-Disposition` header. If filename is specified, you can leave content type blank - if content type is not set, it is detected from the filename.\n\n```javascript\nnew BuildMail('multipart/mixed').\n  createChild(false, {filename: 'image.png'}).\n  setHeader('Content-Disposition', 'attachment');\n```\n\nObviously you might want to add `Content-Id` header as well if you want to reference this attachment from the HTML content.\n\n### MIME structure\n\nMost probably you only need to deal with the following multipart types when generating messages:\n\n  * **multipart/alternative** - includes the same content in different forms (usually text/plain + text/html)\n  * **multipart/related** - includes main node and related nodes (eg. text/html + referenced attachments). Also requires a `type` parameter that indicates the Content-Type of the *root* element in the node\n  * **multipart/mixed** - includes other multipart nodes and attachments, or single content node and attachments\n\n**Examples**\n\nOne content node and an attachment\n\n```\nmultipart/mixed\n  ↳ text/plain\n  ↳ image/png\n```\n\nContent node with referenced attachment (eg. image with `Content-Type` referenced by `cid:` url in the HTML)\n\n```\nmultipart/related\n  ↳ text/html\n  ↳ image/png\n```\n\nPlaintext and HTML alternatives\n\n```\nmultipart/alternative\n  ↳ text/html\n  ↳ text/plain\n```\n\nOne content node with referenced attachment and a regular attachment\n\n```\nmultipart/mixed\n  ↳ multipart/related\n    ↳ text/plain\n    ↳ image/png\n  ↳ application/x-zip\n```\n\nAlternative content with referenced attachment for HTML and a regular attachment\n\n```\nmultipart/mixed\n  ↳ multipart/alternative\n    ↳ text/plain\n    ↳ multipart/related\n      ↳ text/html\n      ↳ image/png\n  ↳ application/x-zip\n```\n\n## License\n\n**MIT**",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/andris9/buildmail/issues"
  },
  "homepage": "https://github.com/andris9/buildmail",
  "_id": "buildmail@1.2.0",
  "_from": "buildmail@^1.2.0"
}
