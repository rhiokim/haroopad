{
  "name": "double-ended-queue",
  "description": "Extremely fast double-ended queue implementation",
  "version": "2.0.0-0",
  "keywords": [
    "data-structure",
    "data-structures",
    "queue",
    "deque",
    "double-ended-queue"
  ],
  "scripts": {
    "test": "grunt test"
  },
  "homepage": "https://github.com/petkaantonov/deque",
  "repository": {
    "type": "git",
    "url": "git://github.com/petkaantonov/deque.git"
  },
  "bugs": {
    "url": "http://github.com/petkaantonov/deque/issues"
  },
  "license": "MIT",
  "author": {
    "name": "Petka Antonov",
    "email": "petka_antonov@hotmail.com",
    "url": "http://github.com/petkaantonov/"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.4",
    "jshint-stylish": "latest",
    "acorn": "~0.3.1",
    "mocha": "~1.12.1",
    "grunt-cli": "~0.1.9",
    "bluebird": "~0.11",
    "benchmark": "~1.0.0",
    "deque": "0.0.4",
    "q": "~0.9.7",
    "semver-utils": "~1.1.0"
  },
  "readmeFilename": "README.md",
  "main": "./js/deque.js",
  "readme": "#Introduction\n\nExtremely fast [double-ended queue](http://en.wikipedia.org/wiki/Double-ended_queue) implementation. Double-ended queue can also be used as a:\n\n- [Stack](http://en.wikipedia.org/wiki/Stack_\\(abstract_data_type\\))\n- [Queue](http://en.wikipedia.org/wiki/Queue_\\(data_structure\\))\n\nThe implementation is GC and CPU cache friendly [circular buffer](http://en.wikipedia.org/wiki/Circular_buffer). [It will run circles around any \"linked list\" implementation](#performance).\n\nEvery queue operation is done in constant `O(1)` - including random access from `.get()`.\n\n#Topics\n\n- [Quick start](#quick-start)\n- [Why not use an Array?](#why-not-use-an-array)\n- [Using double-ended queue as a normal queue](#using-double-ended-queue-as-a-normal-queue)\n- [API reference and examples](#api)\n- [Performance](#performance)\n\n#Quick start\n\n    npm install double-ended-queue\n\n```js\nvar Deque = require(\"double-ended-queue\");\n\nvar deque = new Deque([1,2,3,4]);\ndeque.shift(); //1\ndeque.pop(); //4\n```\n\n#Why not use an Array?\n\nArrays take linear `O(N)` time to do `shift` and `unshift` operations. That means in theory that an array with 1000 items is 1000x slower to do those operations than a deque with 1000 items. 10000x slower with 10000 items and so on.\n\nV8 implements [a trick for small arrays](https://code.google.com/p/v8/issues/detail?id=3059) where these operations are done in constant time, however even with this trick deque is still 4x faster.\n\nBut arrays use \"native\" methods, they must be faster!\n\nIn V8, there is almost no advantage for a method to be a built-in. In fact many times built-ins are at a severe disadvantage of having to implement far more complex semantics than is actually needed in practice. For example, sparse array handling punishes almost every built-in array method even though nobody uses sparse arrays as is evidenced by the popularity of the underscore library which doesn't handle sparse arrays in the same way across different browsers.\n\n#Using double-ended queue as a normal queue\n\nQueue is a more commonly needed data structure however a separate implementation does not provide any advantage in terms of performance. Aliases are provided specifically for the queue use-case. You may use `.enqueue(items...)` to enqueue item(s) and `.dequeue()` to dequeue an item.\n\n#API\n\n- [`new Deque()`](#new-deque---deque)\n- [`new Deque(Array items)`](#new-dequearray-items---deque)\n- [`new Deque(int capacity)`](#new-dequeint-capacity---deque)\n- [`push(dynamic items...)`](#pushdynamic-items---int)\n- [`unshift(dynamic items...)`](#unshiftdynamic-items---int)\n- [`pop()`](#pop---dynamic)\n- [`shift()`](#shift---dynamic)\n- [`toArray()`](#toarray---array)\n- [`peekBack()`](#peekback---dynamic)\n- [`peekFront()`](#peekfront---dynamic)\n- [`get(int index)`](#getint-index---dynamic)\n- [`isEmpty()`](#isempty---boolean)\n- [`clear()`](#clear---void)\n\n#####`new Deque()` -> `Deque`\n\nCreates an empty double-ended queue with initial capacity of 16. If you know the optimal size before-hand, use [`new Deque(int capacity)`](#new-dequeint-capacity---deque).\n\n```js\nvar deque = new Deque();\ndeque.push(1, 2, 3);\ndeque.shift(); //1\ndeque.pop(); //3\n```\n\n<hr>\n\n#####`new Deque(Array items)` -> `Deque`\n\nCreates a double-ended queue from `items`.\n\n```js\nvar deque = new Deque([1,2,3,4]);\ndeque.shift(); //1\ndeque.pop(); //4\n```\n\n<hr>\n\n#####`new Deque(int capacity)` -> `Deque`\n\nCreates an empty double-ended queue with the given `capacity`. `Capacity` should be the maximum amount of items the queue will hold at a given time.\n\nThe reason to give an initial capacity is to avoid potentially expensive resizing operations at runtime.\n\n```js\nvar deque = new Deque(100);\ndeque.push(1, 2, 3);\ndeque.shift(); //1\ndeque.pop(); //3\n```\n\n<hr>\n\n#####`push(dynamic items...)` -> `int`\n\nPush items to the back of this queue. Returns the amount of items currently in the queue after the operation.\n\n```js\nvar deque = new Deque();\ndeque.push(1);\ndeque.pop(); //1\ndeque.push(1, 2, 3);\ndeque.shift(); //1\ndeque.shift(); //2\ndeque.shift(); //3\n```\n\n**Aliases:** `enqueue`, `insertBack`\n\n<hr>\n\n#####`unshift(dynamic items...)` -> `int`\n\nUnshift items to the front of this queue. Returns the amount of items currently in the queue after the operation.\n\n```js\nvar deque = new Deque([2,3]);\ndeque.unshift(1);\ndeque.toString(); //\"1,2,3\"\ndeque.unshift(-2, -1, 0);\ndeque.toString(); //\"-2,-1,0,1,2,3\"\n```\n\n**Aliases:** `insertFront`\n\n<hr>\n\n\n#####`pop()` -> `dynamic`\n\nPop off the item at the back of this queue.\n\nNote: The item will be removed from the queue. If you simply want to see what's at the back of the queue use [`peekBack()`](#peekback---dynamic) or [`.get(-1)`](#getint-index---dynamic).\n\nIf the queue is empty, `undefined` is returned. If you need to differentiate between `undefined` values in the queue and `pop()` return value -\ncheck the queue `.length` before popping.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.pop(); //3\ndeque.pop(); //2\ndeque.pop(); //1\ndeque.pop(); //undefined\n```\n\n**Aliases:** `removeBack`\n\n<hr>\n\n#####`shift()` -> `dynamic`\n\nShifts off the item at the front of this queue.\n\nNote: The item will be removed from the queue. If you simply want to see what's at the front of the queue use [`peekFront()`](#peekfront---dynamic) or [`.get(0)`](#getint-index---dynamic).\n\nIf the queue is empty, `undefined` is returned. If you need to differentiate between `undefined` values in the queue and `shift()` return value -\ncheck the queue `.length` before shifting.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.shift(); //1\ndeque.shift(); //2\ndeque.shift(); //3\ndeque.shift(); //undefined\n```\n\n**Aliases:** `removeFront`, `dequeue`\n\n<hr>\n\n#####`toArray()` -> `Array`\n\nReturns the items in the queue as an array. Starting from the item in the front of the queue and ending to the item at the back of the queue.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.push(4);\ndeque.unshift(0);\ndeque.toArray(); //[0,1,2,3,4]\n```\n\n**Aliases:** `toJSON`\n\n<hr>\n\n#####`peekBack()` -> `dynamic`\n\nReturns the item that is at the back of this queue without removing it.\n\nIf the queue is empty, `undefined` is returned.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.push(4);\ndeque.peekBack(); //4\n```\n\n<hr>\n\n#####`peekFront()` -> `dynamic`\n\nReturns the item that is at the front of this queue without removing it.\n\nIf the queue is empty, `undefined` is returned.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.push(4);\ndeque.peekFront(); //1\n```\n\n<hr>\n\n#####`get(int index)` -> `dynamic`\n\nReturns the item that is at the given `index` of this queue without removing it.\n\nThe index is zero-based, so `.get(0)` will return the item that is at the front, `.get(1)` will return\nthe item that comes after and so on.\n\nThe index can be negative to read items at the back of the queue. `.get(-1)` returns the item that is at the back of the queue,\n`.get(-2)` will return the item that comes before and so on.\n\nReturns `undefined` if `index` is not a valid index into the queue.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.get(0); //1\ndeque.get(1); //2\ndeque.get(2); //3\n\ndeque.get(-1); //3\ndeque.get(-2); //2\ndeque.get(-3); //1\n```\n\n**Note**: Even though indexed accessor (e.g. `queue[0]`) could *appear* to return a correct value *sometimes*, this is completely unreliable. The numeric slots\nof the deque object are internally used as an optimization and have no meaningful order or meaning to outside. Always use `.get()`.\n\n**Note**: The implementation has O(1) random access using `.get()`.\n\n<hr>\n\n#####`isEmpty()` -> `boolean`\n\nReturn `true` if this queue is empty, `false` otherwise.\n\n```js\nvar deque = new Deque();\ndeque.isEmpty(); //true\ndeque.push(1);\ndeque.isEmpty(); //false\n```\n\n<hr>\n\n#####`clear()` -> `void`\n\nRemove all items from this queue. Does not change the queue's capacity.\n\n```js\nvar deque = new Deque([1,2,3]);\ndeque.toString(); //\"1,2,3\"\ndeque.clear();\ndeque.toString(); //\"\"\n```\n<hr>\n\n#Performance\n\nClone the repo and `npm install`. Then run the `bench` script.\n\n##1000 items in the queue\n\n    double-ended-queue x 15,532,714 ops/sec ±0.19% (96 runs sampled)\n    built-in array x 6,501,398 ops/sec ±0.87% (95 runs sampled)\n    node-deque x 2,938,068 ops/sec ±3.50% (68 runs sampled)\n\n##2 million items in the queue\n\n    double-ended-queue x 14,425,547 ops/sec ±0.17% (94 runs sampled)\n    node-deque x 2,815,628 ops/sec ±10.56% (76 runs sampled)\n    built-in array x 19.23 ops/sec ±0.35% (51 runs sampled)\n\nNoteworthy is just how bad the degradation can be for built-in array when V8 cannot use the trick.\n",
  "_id": "double-ended-queue@2.0.0-0",
  "_from": "double-ended-queue@^2.0.0-0"
}
