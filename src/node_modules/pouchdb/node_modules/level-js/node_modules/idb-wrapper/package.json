{
  "name": "idb-wrapper",
  "version": "1.4.1",
  "description": "A cross-browser wrapper for IndexedDB",
  "keywords": [
    "storage",
    "offline",
    "IndexedDB"
  ],
  "author": {
    "name": "jensarps",
    "email": "mail@jensarps.de",
    "url": "http://jensarps.de/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jensarps/IDBWrapper.git"
  },
  "main": "idbstore",
  "homepage": "https://github.com/jensarps/IDBWrapper",
  "contributors": [
    {
      "name": "Josh Matthews",
      "email": "josh@joshmatthews.net",
      "url": "http://www.joshmatthews.net/blog/"
    },
    {
      "name": "Raynos",
      "email": "raynos2@gmail.com",
      "url": "http://raynos.org"
    },
    {
      "name": "Chad Engler",
      "email": "chad@pantherdev.com",
      "url": "http://chad.pantherdev.com"
    },
    {
      "name": "Max Ogden",
      "email": "max+ogden@maxogden.com",
      "url": "http://www.maxogden.com"
    },
    {
      "name": "Asa Ayers",
      "email": "asa.ayers@gmail.com"
    }
  ],
  "bugs": {
    "url": "https://github.com/jensarps/IDBWrapper/issues",
    "email": "mail@jensarps.de"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "~1.13.0",
    "chai": "~1.8.1"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/jensarps/IDBWrapper/raw/master/LICENSE"
    }
  ],
  "scripts": {},
  "readme": "About\n=====\n\nIDBWrapper is a cross-browser wrapper for the HTML5 IndexedDB API. While this\nAPI is the future of offline storage, it is not very intuitive to use.\nIDBWrapper is there to provide easy access to IndexedDB's features.\n\n##Browser Support\n\nIDBWrapper works on all browsers supperting the IndexedDB API, which are:\n\n**Desktop**\n\n* Chrome\n* Firefox\n* Opera 15+\n* IE 10+\n\n**Mobile**\n\n* Chrome for Android\n* Firefox for Android\n* Opera for Android\n* IE10 for WP8\n\n**Worker** IDBWrapper runs inside of a worker on following browsers:\n\n* Chrome\n* Chrome for Android\n* Firefox\n* Opera\n* Opera for Android\n* IE10\n* IE10 for WP8\n\n##Tutorials\n\nThere are two tutorials to get you up and running:\n\nPart 1: Setup and CRUD operations\nhttp://jensarps.de/2011/11/25/working-with-idbwrapper-part-1/\n\nPart 2: Running Queries against the store\nhttp://jensarps.de/2012/11/13/working-with-idbwrapper-part-2/\n\nExamples\n========\n\nThere are some examples to run right in your browser over here: http://jensarps.github.com/IDBWrapper/example/\n\nThe source for these examples are in the `example` folder of this repository.\n\nAPI Reference\n=============\n\nThere's an API reference over here: http://jensarps.github.com/IDBWrapper/jsdoc/IDBStore.html\n\nYou can create a local version of the reference using a terminal. Go into the\nIDBWrapper directory and run the following command:\n\n```bash\n$ make doc\n```\n\nObtaining IDBWrapper\n====================\n\nYou can git clone the repository, or download a zip file here: https://github.com/jensarps/IDBWrapper/tags\n\nIDBWrapper is also available on [cdnjs](http://cdnjs.com/), so you can directly point a script tag there, or require() \nit from there. cdnjs supports http, https and spdy, so you can just leave the protocol off. The URL is:\n\n```\n//cdnjs.cloudflare.com/ajax/libs/idbwrapper/1.4.0/idbstore.min.js\n```\n\nIf you use NPM as your package manager, you can get it from there, too, by\nrunning:\n\n```bash\n$ npm install idb-wrapper\n```\n\nIf you use bower as your package manager, run the following:\n\n```bash\n$ bower install idbwrapper\n```\n\nIf you want to add IDBWrapper to a volo project, just run:\n\n```bash\n$ volo add idbwrapper\n```\n\n\nUsage\n=====\n\nIncluding the idbstore.js file will add an IDBStore constructor to the global scope.\n\nAlternatively, you can use an AMD loader such as RequireJS, or a CommonJS loader\nto load the module, and you will receive the constructor in your load callback\n(the constructor will then, of course, have whatever name you call it).\n\n\nYou can then create an IDB store:\n\n```javascript\nvar myStore = new IDBStore();\n```\n\nYou may pass two parameters to the constructor: the first is an object with optional parameters,\nthe second is a function reference to a function that is called when the store is ready to use.\n\nThe options object may contain the following properties (default values are shown -- all\nproperties are optional):\n\n```javascript\n{\n  storeName: 'Store',\n  storePrefix: 'IDBWrapper-',\n  dbVersion: 1,\n  keyPath: 'id',\n  autoIncrement: true,\n  indexes: [],\n  onStoreReady: function(){},\n  onError: function(error){ throw error; }\n}\n```\n\n'storeName' is the name of the store: for different stores, use different names.\n\n'storePrefix' is an additional prefix; the created database will finally have\nthe name \"storePrefix+storeName\". You can safely ignore this property, but if\nyou want to have full control over the IDB name, you can pass your own prefix.\n\n'dbVersion' is the version number of your store. You'll only have to provide\nthis if you change the structure of the store at a later time.\n\n'keyPath' is the name of the property to be used as key index. If `autoIncrement` is set to true,\nthe database will automatically add a unique key to the keyPath index when storing objects missing\nthat property. If you want to use out-of-line keys, you must set this  property to `null` (see below for details on out-of-line keys).\n\n'indexes' contains objects defining indexes (see below for details on indexes).\n\n'autoIncrement' is a boolean and toggles, well, auto-increment on or off. You\ncan leave it to true, even if you do provide your own ids.\n\n'indexes' is an array of indexes. See below for further info on indexes.\n\n'onError' gets called if an error occurred while trying to open the store. It\nreceives the error instance as only argument.\n\nAs an alternative to passing a ready handler as second argument, you can also\npass it in the 'onStoreReady' property. If a callback is provided both as second\nparameter and inside of the options object, the function passed as second\nparameter will be used.\n\n### Out-of-line Keys\n\nIDBWrapper supports working with out-of-line keys. This is a feature of IndexedDB, and it means that an object's identifier is not kept on the object itself. Usually, you'll want to go with the default way, using in-line keys. If you, however, want to use out-of-line keys, note that the `put()` and `batch()` methods behave differently, and that the `autoIncrement` property has no effect – you MUST take care of the ids yourself!\n\nMethods\n=======\n\nHere's an overview of available methods in IDBStore:\n\nData Manipulation\n-----------------\n\nUse the following methods to read and write data (all methods in this section return the `IDBTransaction` they open):\n\n___\n\n\n1) The put method.\n\n\n```javascript\nput(/*Object*/ dataObj, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`dataObj` is the Object to store. `onSuccess` will be called when the insertion/update was successful,\nand it will receive the keyPath value (the id, so to say) of the inserted object as first and only\nargument. `onError` will be called if the insertion/update failed and it will receive the error event\nobject as first and only argument. If the store already contains an object with the given keyPath id,\nit will be overwritten by `dataObj`.\n\n**Out-of-line Keys**\n\nIf you use out-of-line keys in your store, you must provide a key as first argument to the put method:\n\n```javascript\nput(/*Anything*/ key, /*Object*/ dataObj, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\nThe `onSuccess` and `onError` arguments remain optional.\n\n___\n\n\n2) The get method.\n\n```javascript\nget(/*keyPath value*/ key, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`key` is the keyPath property value (the id) of the object to retrieve. `onSuccess` will be called if\nthe get operation was successful, and it will receive the stored object as first and only argument. If\nno object was found with the given keyPath value, this argument will be null. `onError` will be called\nif the get operation failed and it will receive the error event object as first and only argument.\n\n___\n\n\n3) The getAll method.\n\n```javascript\ngetAll: function(/*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`onSuccess` will be called if the getAll operation was successful, and it will receive an Array of\nall objects currently stored in the store as first and only argument. `onError` will be called if\nthe getAll operation failed and it will receive the error event object as first and only argument.\n\n___\n\n\n4) The remove method.\n\n```javascript\nremove: function(/*keyPath value*/ key, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`key` is the keyPath property value (the id) of the object to remove. `onSuccess` will be called if\nthe remove operation was successful, and it _should_ receive `false` as first and only argument if the\nobject to remove was not found, and `true` if it was found and removed.\n\nNOTE: FF 8 will pass the key to the onSuccess handler, no matter if there is an corresponding object\nor not. Chrome 15 will pass `null` if removal was successful, and call the error handler if the object\nwasn't found. Chrome 17 will behave as described above.\n\n`onError` will be called if the remove operation failed and it will receive the error event object as first\nand only argument.\n\n___\n\n\n5) The clear method.\n\n```javascript\nclear: function(/*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`onSuccess` will be called if the clear operation was successful. `onError` will be called if the clear\noperation failed and it will receive the error event object as first and only argument.\n\n##Batch Operations\n\nIDBWrapper allows to run a single method when dealing with multiple objects. All methods in this section return the `IDBTransaction` they open.\n\n1) The getBatch method.\n\n```javascript\ngetBatch: function (/*Array*/keyArray, /*Function?*/onSuccess, /*Function?*/onError, /*String?*/arrayType)\n```\n\nThis method takes an array of keys and fetches matching objects. \n\n`keyArray` must be an array of keys identifying the objects to fetch.\n\n`arrayType` defines the type of array to pass to the success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to 'sparse'. This parameter specifies how to handle the situation if a get operation did not throw an error, but there was no matching object in the database. In most cases, 'sparse' provides the most desired behavior. See the examples for details:\n\n```javascript\n// given that there are two objects in the database with the keypath\n// values 1 and 2, and the call looks like this:\nmyStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);\n\n// this is what the `data` array will be like:\n\n// arrayType == 'sparse':\n// data is a sparse array containing two entries and having a length of 3:\n       [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         __proto__: Array[0]\n// calling forEach on data will result in the callback being called two\n// times, with the index parameter matching the index of the key in the\n// keyArray.\n\n// arrayType == 'dense':\n// data is a dense array containing three entries and having a length of 3,\n// where data[1] is of type undefined:\n       [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         __proto__: Array[0]\n// calling forEach on data will result in the callback being called three\n// times, with the index parameter matching the index of the key in the\n// keyArray, but the second call will have undefined as first argument.\n\n// arrayType == 'skip':\n// data is a dense array containing two entries and having a length of 2:\n       [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         __proto__: Array[0]\n// calling forEach on data will result in the callback being called two\n// times, with the index parameter not matching the index of the key in the\n// keyArray.\n\n```    \n\n\n___\n\n\n2) The putBatch method.\n\n```javascript\nputBatch: function (/*Array*/dataArray, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`putBatch` takes an array of objects and stores them in a single transaction.\n\n\n**Out-of-line Keys**\n\nThe `putBatch` method does not support out-of-line keys. If you need to store multiple out-of-line objects, use the `batch` method.\n\n\n___\n\n\n3) The removeBatch method.\n\n```javascript\nremoveBatch: function (/*Array*/keyArray, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`removeBatch` takes an array of keys and removes matching objects in a single transaction.\n\n---\n\n\n4) The batch method.\n\n```javascript\nbatch: function (/*Array*/operations, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\nThis method allows you to combine put and remove actions in a single call. `batch` expects an array of operations that you want to apply in a single\nIndexedDB transaction. `operations` is an Array of objects, each containing two\nproperties, defining the type of operation. There are two operations\nsupported, put and remove. A put entry looks like this:\n\n```javascript\n{ type: \"put\", value: dataObj } // dataObj being the object to store\n```\n\nA remove entry looks like this;\n\n```javascript\n{ type: \"remove\", key: someKey } // someKey being the keyPath value of the item to remove\n```\n\nYou can mix both types in the `operations` Array:\n\n```javascript\nbatch([\n  { type: \"put\", value: dataObj },\n  { type: \"remove\", key: someKey }\n], onSuccess, onError)\n```\n\n`onSuccess` will be called if all operations were successful and will receive no\narguments. `onError` will be called if an error happens for one of the\noperations and will receive three arguments: the Error instance, the type of\noperation that caused the error and either the key or the value property\n(depending on the type).\n\nIf an error occurs, no changes will be made to the store, even if some\nof the given operations would have succeeded.\n\n\n**Out-of-line Keys**\n\nIf you use out-of-line keys, you must also provide a key to put operations: \n\n\n```javascript\n{ type: \"put\", value: dataObj, key: 12345 } // also add a `key` property containing the object's identifier\n```\n\n\n\nIndex Operations\n----------------\n\nTo create indexes, you need to pass the index information to the IDBStore()\nconstructor, for example:\n\n\n```javascript\n{\n  storeName: 'customers',\n  dbVersion: 1,\n  keyPath: 'customerid',\n  autoIncrement: true,\n  onStoreReady: function(){},\n  indexes: [\n    { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n  ]\n}\n```\n\nAn entry in the index Array is an object containing the following properties:\n\nThe `name` property is the identifier of the index. If you want to work with the created index later, this name is used to identify the index. This is the only property that is mandatory.\n\nThe `keyPath` property is the name of the property in your stored data that you want to index. If you omit that, IDBWrapper will assume that it is the same as the provided name, and will use this instead.\n\nThe `unique` property tells the store whether the indexed property in your data is unique. If you set this to true, it will add a uniqueness constraint to the store which will make it throw if you try to store data that violates that constraint. If you omit that, IDBWrapper will set this to false.\n\nThe `multiEntry` property is kinda weird. You can read up on it here: http://www.w3.org/TR/IndexedDB/#dfn-multientry. However, you can live perfectly fine with setting this to false (or just omitting it, this is set to false by default).\n\n\nIf you want to add an index to an existing store, you need to increase the\nversion number of your store, as adding an index changes the structure of\nthe database.\n\nTo modify an index, modify the object in the indexes Array in the constructor.\nAgain, you need to increase the version of your store.\n\nIn addition, there are still some convenience methods available:\n\n___\n\n\n1) The hasIndex method.\n\n```javascript\nhasIndex: function(/*String*/ indexName)\n```\n\nReturn true if an index with the given name exists in the store, false if not.\n\n___\n\n2) The getIndexList method.\n\n```javascript\ngetIndexList: function()\n```\n\nReturns a `DOMStringList` with all existing indices.\n\n\nRunning Queries\n---------------\n\nTo run queries, IDBWrapper provides a `query()` and an `iterate()` method. To create keyRanges, there is the `makeKeyRange()` method. In addition to these, IDBWrapper comes with a `count()` method. The `query`, `iterate` and `count` methods return the `IDBTransaction` they open.\n\n___\n\n\n1) The iterate method.\n\n\n```javascript\niterate: function(/*Function*/ onItem, /*Object*/ iterateOptions)\n```\n\nThe `onItem` callback will be called once for every match. It will receive three arguments: the object that matched the query, a reference to the current cursor object (IDBWrapper uses IndexedDB's Cursor internally to iterate), and a reference to the current ongoing transaction.\n\nThere's one special situation: if you didn't pass an onEnd handler in the options objects (see below), the onItem handler will be called one extra time when the transaction is over. In this case, it will receive null as only argument. So, to check when the iteration is over and you won't get any more data objects, you can either pass an onEnd handler, or check for null in the onItem handler.\n\nThe `iterateOptions` object can contain one or more of the following properties:\n\nThe `index` property contains the name of the index to operate on. If you omit this, IDBWrapper will use the store's keyPath as index.\n\nIn the `keyRange` property you can pass a keyRange.\n\nThe `order` property can be set to 'ASC' or 'DESC', and determines the ordering direction of results. If you omit this, IDBWrapper will use 'ASC'.\n\nThe `autoContinue` property defaults to true. If you set this to false, IDBWrapper will not automatically advance the cursor to next result, but instead pause after it obtained a result. To move the cursor to the next result, you need to call the cursor object's `continue()` method (you get the cursor object as second argument to the `onItem` callback).\n\nThe `filterDuplicates` property is an interesting one: If you set this to true (it defaults to false), and have several objects that have the same value in their key, the store will only fetch the first of those. It is not about objects being the same, it's about their key being the same. For example, in the customers database are a couple of guys having 'Smith' as last name. Setting filterDuplicates to true in the above example will make `iterate()` call the onItem callback only for the first of those.\n\nThe `writeAccess` property defaults to false. If you need write access to the store during the iteration, you need to set this to true.\n\nIn the `onEnd` property you can pass a callback that gets called after the iteration is over and the transaction is closed. It does not receive any arguments.\n\nIn the `onError` property you can pass a custom error handler. In case of an error, it will be called and receives the Error object as only argument.\n\n___\n\n\n2) The query method.\n\n\n```javascript\nquery: function(/*Function*/ onSuccess, /*Object*/ queryOptions)\n```\n\nThe query() method is just like the iterate() method, except that it will call\nthe onSuccess callback with an array of the matched objects instead of calling\na callback for each item.\n\nThe `onSuccess` callback will be called if the operation was successful, and it\nwill receive an array objects as only argument.\n\nThe `queryOptions` object can contain one or more of the following properties:\n\nThe `index` property contains the name of the index to operate on. If you omit this, IDBWrapper will use the store's keyPath as index.\n\nIn the `keyRange` property you can pass a keyRange.\n\nThe `order` property can be set to 'ASC' or 'DESC', and determines the ordering direction of results. If you omit this, IDBWrapper will use 'ASC'.\n\nThe `filterDuplicates` property is an interesting one: If you set this to true (it defaults to false), and have several objects that have the same value in their key, the store will only fetch the first of those. It is not about objects being the same, it's about their key being the same. For example, in the customers database are a couple of guys having 'Smith' as last name. Setting filterDuplicates to true in the above example will make `iterate()` call the onItem callback only for the first of those.\n\nIn the `onError` property you can pass a custom error handler. In case of an error, it will be called and receives the Error object as only argument.\n\n___\n\n3) The makeKeyRange method.\n\n\n```javascript\nmakeKeyRange: function(/*Object*/ keyRangeOptions)\n```\n\nReturns an IDBKeyRange.\n\nThe `keyRangeOptions` object must have one or more of the following properties:\n\n`lower`: The lower bound of the range\n\n`excludeLower`: Boolean, whether to exclude the lower bound itself. Default: false\n\n`upper`: The upper bound of the range\n\n`excludeUpper`: Boolean, whether to exclude the upper bound itself. Default: false\n\n`only`: If you want a key range around only one value, pass just this property.\n\n___\n\n\n4) The count method.\n\n\n```javascript\ncount: function(/*Function*/ onSuccess, /*Object*/ countOptions)\n```\n\nThe onSuccess receives the result of the count as only argument.\n\nThe `countOptions` object may have one or more of the following properties:\n\nindex: The name of an index to operate on.\n\nkeyRange: A keyRange to use\n\n",
  "readmeFilename": "README.md",
  "_id": "idb-wrapper@1.4.1",
  "_from": "idb-wrapper@>=1.4.1 <1.5.0"
}
